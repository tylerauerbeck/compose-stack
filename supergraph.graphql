schema
  @link(url: "https://specs.apollo.dev/link/v1.0")
  @link(url: "https://specs.apollo.dev/join/v0.3", for: EXECUTION)
{
  query: Query
  mutation: Mutation
}

directive @join__enumValue(graph: join__Graph!) repeatable on ENUM_VALUE

directive @join__field(graph: join__Graph, requires: join__FieldSet, provides: join__FieldSet, type: String, external: Boolean, override: String, usedOverridden: Boolean) repeatable on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @join__graph(name: String!, url: String!) on ENUM_VALUE

directive @join__implements(graph: join__Graph!, interface: String!) repeatable on OBJECT | INTERFACE

directive @join__type(graph: join__Graph!, key: join__FieldSet, extension: Boolean! = false, resolvable: Boolean! = true, isInterfaceObject: Boolean! = false) repeatable on OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT | SCALAR

directive @join__unionMember(graph: join__Graph!, member: String!) repeatable on UNION

directive @link(url: String, as: String, for: link__Purpose, import: [link__Import]) repeatable on SCHEMA

type Annotation implements Node
  @join__implements(graph: METADATA_API, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__type(graph: METADATA_API, key: "id")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  """ID for the annotation."""
  id: ID!
  createdAt: Time! @join__field(graph: METADATA_API)
  updatedAt: Time! @join__field(graph: METADATA_API)

  """ID of the metadata of this annotation"""
  metadataID: ID! @join__field(graph: METADATA_API)

  """JSON formatted data of this annotation."""
  data: JSON! @join__field(graph: METADATA_API)
  namespace: AnnotationNamespace! @join__field(graph: METADATA_API)
  metadata: Metadata! @join__field(graph: METADATA_API)
}

"""A connection to a list of items."""
type AnnotationConnection
  @join__type(graph: METADATA_API)
{
  """A list of edges."""
  edges: [AnnotationEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""Input information to delete an annotation."""
input AnnotationDeleteInput
  @join__type(graph: METADATA_API)
{
  """The node ID for this annotation."""
  nodeID: ID!

  """The namespace ID for this annotation."""
  namespaceID: ID!
}

"""Return response from annotationDelete"""
type AnnotationDeleteResponse
  @join__type(graph: METADATA_API)
{
  """The ID of the unset annotation."""
  deletedID: ID!
}

"""An edge in a connection."""
type AnnotationEdge
  @join__type(graph: METADATA_API)
{
  """The item at the end of the edge."""
  node: Annotation

  """A cursor for use in pagination."""
  cursor: Cursor!
}

type AnnotationNamespace implements Node
  @join__implements(graph: METADATA_API, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__type(graph: METADATA_API, key: "id")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  """The ID for the annotation namespace."""
  id: ID!
  createdAt: Time! @join__field(graph: METADATA_API)
  updatedAt: Time! @join__field(graph: METADATA_API)

  """The name of the annotation namespace."""
  name: String! @join__field(graph: METADATA_API)

  """Flag for if this namespace is private."""
  private: Boolean! @join__field(graph: METADATA_API)
  annotations: [Annotation!] @join__field(graph: METADATA_API)

  """The owner of the annotation namespace."""
  owner: ResourceOwner! @join__field(graph: METADATA_API)
}

"""A connection to a list of items."""
type AnnotationNamespaceConnection
  @join__type(graph: METADATA_API)
{
  """A list of edges."""
  edges: [AnnotationNamespaceEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""Return response from annotationNamespaceCreate"""
type AnnotationNamespaceCreatePayload
  @join__type(graph: METADATA_API)
{
  """The created annotation namespace."""
  annotationNamespace: AnnotationNamespace!
}

"""Return response from annotationNamespaceDelete"""
type AnnotationNamespaceDeletePayload
  @join__type(graph: METADATA_API)
{
  """The ID of the deleted annotation namespace."""
  deletedID: ID!

  """The count of annotations deleted"""
  annotationDeletedCount: Int!
}

"""An edge in a connection."""
type AnnotationNamespaceEdge
  @join__type(graph: METADATA_API)
{
  """The item at the end of the edge."""
  node: AnnotationNamespace

  """A cursor for use in pagination."""
  cursor: Cursor!
}

"""Ordering options for AnnotationNamespace connections"""
input AnnotationNamespaceOrder
  @join__type(graph: METADATA_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order AnnotationNamespaces."""
  field: AnnotationNamespaceOrderField!
}

"""Properties by which AnnotationNamespace connections can be ordered."""
enum AnnotationNamespaceOrderField
  @join__type(graph: METADATA_API)
{
  ID @join__enumValue(graph: METADATA_API)
  CREATED_AT @join__enumValue(graph: METADATA_API)
  UPDATED_AT @join__enumValue(graph: METADATA_API)
  NAME @join__enumValue(graph: METADATA_API)
  OWNER @join__enumValue(graph: METADATA_API)
  PRIVATE @join__enumValue(graph: METADATA_API)
}

"""Return response from annotationNamespaceUpdate"""
type AnnotationNamespaceUpdatePayload
  @join__type(graph: METADATA_API)
{
  """The updated annotation namespace."""
  annotationNamespace: AnnotationNamespace!
}

"""
AnnotationNamespaceWhereInput is used for filtering AnnotationNamespace objects.
Input was generated by ent.
"""
input AnnotationNamespaceWhereInput
  @join__type(graph: METADATA_API)
{
  not: AnnotationNamespaceWhereInput
  and: [AnnotationNamespaceWhereInput!]
  or: [AnnotationNamespaceWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String

  """annotations edge predicates"""
  hasAnnotations: Boolean
  hasAnnotationsWith: [AnnotationWhereInput!]
}

"""Ordering options for Annotation connections"""
input AnnotationOrder
  @join__type(graph: METADATA_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order Annotations."""
  field: AnnotationOrderField!
}

"""Properties by which Annotation connections can be ordered."""
enum AnnotationOrderField
  @join__type(graph: METADATA_API)
{
  CREATED_AT @join__enumValue(graph: METADATA_API)
  UPDATED_AT @join__enumValue(graph: METADATA_API)
}

"""Input information to update an annotation."""
input AnnotationUpdateInput
  @join__type(graph: METADATA_API)
{
  """The node ID for this annotation."""
  nodeID: ID!

  """The namespace ID for this annotation."""
  namespaceID: ID!

  """The data to save in this annotation."""
  data: JSON!
}

"""Return response from annotationUpdate"""
type AnnotationUpdateResponse
  @join__type(graph: METADATA_API)
{
  """The set annotation."""
  annotation: Annotation!
}

"""
AnnotationWhereInput is used for filtering Annotation objects.
Input was generated by ent.
"""
input AnnotationWhereInput
  @join__type(graph: METADATA_API)
{
  not: AnnotationWhereInput
  and: [AnnotationWhereInput!]
  or: [AnnotationWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """namespace edge predicates"""
  hasNamespace: Boolean
  hasNamespaceWith: [AnnotationNamespaceWhereInput!]

  """metadata edge predicates"""
  hasMetadata: Boolean
  hasMetadataWith: [MetadataWhereInput!]
}

"""Input information to create an annotation namespace."""
input CreateAnnotationNamespaceInput
  @join__type(graph: METADATA_API)
{
  """The name of the annotation namespace."""
  name: String!

  """The ID for the owner for this annotation namespace."""
  ownerID: ID!

  """Flag for if this namespace is private."""
  private: Boolean
}

"""Input information to create a location."""
input CreateLocationInput
  @join__type(graph: LOCATION_API)
{
  """The name for the location."""
  name: String!

  """An optional description for the location."""
  description: String

  """The ID of the resource owner for the location."""
  ownerID: ID!
}

"""Input information to create a status namespace."""
input CreateStatusInput
  @join__type(graph: METADATA_API)
{
  source: String!

  """JSON formatted data of this annotation."""
  data: JSON!
  namespaceID: ID!
  metadataID: ID!
}

"""Input information to create a status namespace."""
input CreateStatusNamespaceInput
  @join__type(graph: METADATA_API)
{
  """The name of the status namespace."""
  name: String!

  """The ID for the tenant for this status namespace."""
  resourceProviderID: ID!

  """Flag for if this namespace is private."""
  private: Boolean
}

"""Input information to create a tenant."""
input CreateTenantInput
  @join__type(graph: TENANT_API)
{
  """The name of a tenant."""
  name: String!

  """An optional description of the tenant."""
  description: String
  parentID: ID
}

"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: TENANT_API)

scalar join__FieldSet

enum join__Graph {
  LOCATION_API @join__graph(name: "location-api", url: "http://location-api:7906/query")
  METADATA_API @join__graph(name: "metadata-api", url: "http://metadata-api:7905/query")
  NODE_RESOLVER @join__graph(name: "node-resolver", url: "http://node-resolver:7904/query")
  TENANT_API @join__graph(name: "tenant-api", url: "http://tenant-api:7902/query")
}

"""A valid JSON string."""
scalar JSON
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: TENANT_API)

scalar link__Import

enum link__Purpose {
  """
  `SECURITY` features provide metadata necessary to securely resolve fields.
  """
  SECURITY

  """
  `EXECUTION` features provide metadata necessary for operation execution.
  """
  EXECUTION
}

type Location implements Node & MetadataNode
  @join__implements(graph: LOCATION_API, interface: "Node")
  @join__implements(graph: LOCATION_API, interface: "MetadataNode")
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "MetadataNode")
  @join__type(graph: LOCATION_API, key: "id")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  """ID for the location."""
  id: ID!
  createdAt: Time! @join__field(graph: LOCATION_API)
  updatedAt: Time! @join__field(graph: LOCATION_API)

  """The name for the location."""
  name: String! @join__field(graph: LOCATION_API)

  """An optional description for the location."""
  description: String @join__field(graph: LOCATION_API)
  owner: ResourceOwner! @join__field(graph: LOCATION_API)
  metadata: Metadata @join__field
}

"""A connection to a list of items."""
type LocationConnection
  @join__type(graph: LOCATION_API)
{
  """A list of edges."""
  edges: [LocationEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""Return response from locationCreate"""
type LocationCreatePayload
  @join__type(graph: LOCATION_API)
{
  """The created annotation namespace."""
  location: Location!
}

"""Return response from locationDelete"""
type LocationDeletePayload
  @join__type(graph: LOCATION_API)
{
  """The ID of the deleted annotation namespace."""
  deletedID: ID!
}

"""An edge in a connection."""
type LocationEdge
  @join__type(graph: LOCATION_API)
{
  """The item at the end of the edge."""
  node: Location

  """A cursor for use in pagination."""
  cursor: Cursor!
}

"""Ordering options for Location connections"""
input LocationOrder
  @join__type(graph: LOCATION_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order Locations."""
  field: LocationOrderField!
}

"""Properties by which Location connections can be ordered."""
enum LocationOrderField
  @join__type(graph: LOCATION_API)
{
  CREATED_AT @join__enumValue(graph: LOCATION_API)
  UPDATED_AT @join__enumValue(graph: LOCATION_API)
  NAME @join__enumValue(graph: LOCATION_API)
}

"""Return response from locationUpdate"""
type LocationUpdatePayload
  @join__type(graph: LOCATION_API)
{
  """The updated annotation namespace."""
  location: Location!
}

"""
LocationWhereInput is used for filtering Location objects.
Input was generated by ent.
"""
input LocationWhereInput
  @join__type(graph: LOCATION_API)
{
  not: LocationWhereInput
  and: [LocationWhereInput!]
  or: [LocationWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
}

type Metadata implements Node
  @join__implements(graph: METADATA_API, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__type(graph: METADATA_API, key: "id")
  @join__type(graph: METADATA_API, key: "nodeID")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  """ID for the metadata."""
  id: ID!
  createdAt: Time! @join__field(graph: METADATA_API)
  updatedAt: Time! @join__field(graph: METADATA_API)

  """ID of the node for this metadata"""
  nodeID: ID! @join__field(graph: METADATA_API)
  annotations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Annotations returned from the connection."""
    orderBy: AnnotationOrder

    """Filtering options for Annotations returned from the connection."""
    where: AnnotationWhereInput
  ): AnnotationConnection! @join__field(graph: METADATA_API)
  statuses(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for StatusSlice returned from the connection."""
    orderBy: StatusOrder

    """Filtering options for StatusSlice returned from the connection."""
    where: StatusWhereInput
  ): StatusConnection! @join__field(graph: METADATA_API)
  node: MetadataNode! @join__field(graph: METADATA_API)
}

"""A connection to a list of items."""
type MetadataConnection
  @join__type(graph: METADATA_API)
{
  """A list of edges."""
  edges: [MetadataEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type MetadataEdge
  @join__type(graph: METADATA_API)
{
  """The item at the end of the edge."""
  node: Metadata

  """A cursor for use in pagination."""
  cursor: Cursor!
}

interface MetadataNode
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API, key: "id", isInterfaceObject: true)
  @join__type(graph: NODE_RESOLVER, key: "id")
  @join__type(graph: TENANT_API)
{
  id: ID!
  metadata: Metadata @join__field(graph: METADATA_API)
}

"""Ordering options for Metadata connections"""
input MetadataOrder
  @join__type(graph: METADATA_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order MetadataSlice."""
  field: MetadataOrderField!
}

"""Properties by which Metadata connections can be ordered."""
enum MetadataOrderField
  @join__type(graph: METADATA_API)
{
  CREATED_AT @join__enumValue(graph: METADATA_API)
  UPDATED_AT @join__enumValue(graph: METADATA_API)
}

"""
MetadataWhereInput is used for filtering Metadata objects.
Input was generated by ent.
"""
input MetadataWhereInput
  @join__type(graph: METADATA_API)
{
  not: MetadataWhereInput
  and: [MetadataWhereInput!]
  or: [MetadataWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """annotations edge predicates"""
  hasAnnotations: Boolean
  hasAnnotationsWith: [AnnotationWhereInput!]

  """statuses edge predicates"""
  hasStatuses: Boolean
  hasStatusesWith: [StatusWhereInput!]
}

type Mutation
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: TENANT_API)
{
  """Create a location."""
  locationCreate(input: CreateLocationInput!): LocationCreatePayload! @join__field(graph: LOCATION_API)

  """Delete a location."""
  locationDelete(
    """The ID of the annotation namespace to be deleted."""
    id: ID!
  ): LocationDeletePayload! @join__field(graph: LOCATION_API)

  """Update a location."""
  locationUpdate(id: ID!, input: UpdateLocationInput!): LocationUpdatePayload! @join__field(graph: LOCATION_API)

  """
  Set Annotation data for a node and annotation namespace to the given value.

  annotationUpdate is an Upsert operation and will create the annotation if it doesn't already exists.
  """
  annotationUpdate(input: AnnotationUpdateInput!): AnnotationUpdateResponse! @join__field(graph: METADATA_API)

  """Delete Annotation for a node and annotation namespace."""
  annotationDelete(input: AnnotationDeleteInput!): AnnotationDeleteResponse! @join__field(graph: METADATA_API)

  """Create an annotation namespace."""
  annotationNamespaceCreate(input: CreateAnnotationNamespaceInput!): AnnotationNamespaceCreatePayload! @join__field(graph: METADATA_API)

  """
  Delete an annotation namespace.

  Setting force allowed deleting an annotation namespace even if annotations are using it.
  WARNING: Annotation data will be lost permenantly!
  """
  annotationNamespaceDelete(
    """The ID of the annotation namespace to be deleted."""
    id: ID!

    """
    Delete the annotation namespace even if annotations are using it. WARNING!! The annotations will also be deleted!
    """
    force: Boolean! = false
  ): AnnotationNamespaceDeletePayload! @join__field(graph: METADATA_API)

  """Update an annotation namespace."""
  annotationNamespaceUpdate(id: ID!, input: UpdateAnnotationNamespaceInput!): AnnotationNamespaceUpdatePayload! @join__field(graph: METADATA_API)

  """
  Set Status data for a node and status namespace to the given value.

  statusUpdate is an Upsert operation and will create the status if it doesn't already exists.
  """
  statusUpdate(input: StatusUpdateInput!): StatusUpdateResponse! @join__field(graph: METADATA_API)

  """Delete Status for a node and status namespace."""
  statusDelete(input: StatusDeleteInput!): StatusDeleteResponse! @join__field(graph: METADATA_API)

  """Create an status namespace."""
  statusNamespaceCreate(input: CreateStatusNamespaceInput!): StatusNamespaceCreatePayload! @join__field(graph: METADATA_API)

  """
  Delete an status namespace.

  Setting force allowed deleting an status namespace even if statuss are using it.
  WARNING: Status data will be lost permenantly!
  """
  statusNamespaceDelete(
    """The ID of the status namespace to be deleted."""
    id: ID!

    """
    Delete the status namespace even if statuss are using it. WARNING!! The statuss will also be deleted!
    """
    force: Boolean! = false
  ): StatusNamespaceDeletePayload! @join__field(graph: METADATA_API)

  """Update an status namespace."""
  statusNamespaceUpdate(id: ID!, input: UpdateStatusNamespaceInput!): StatusNamespaceUpdatePayload! @join__field(graph: METADATA_API)

  """Create a tenant."""
  tenantCreate(input: CreateTenantInput!): TenantCreatePayload! @join__field(graph: TENANT_API)

  """Update a tenant."""
  tenantUpdate(id: ID!, input: UpdateTenantInput!): TenantUpdatePayload! @join__field(graph: TENANT_API)

  """Delete a tenant."""
  tenantDelete(id: ID!): TenantDeletePayload! @join__field(graph: TENANT_API)
}

"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: NODE_RESOLVER, key: "id")
  @join__type(graph: TENANT_API)
{
  """The id of the object."""
  id: ID!
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: TENANT_API)
{
  """Specifies an ascending order for a given `orderBy` argument."""
  ASC @join__enumValue(graph: LOCATION_API) @join__enumValue(graph: METADATA_API) @join__enumValue(graph: TENANT_API)

  """Specifies a descending order for a given `orderBy` argument."""
  DESC @join__enumValue(graph: LOCATION_API) @join__enumValue(graph: METADATA_API) @join__enumValue(graph: TENANT_API)
}

"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: TENANT_API)
{
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type Query
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: NODE_RESOLVER)
  @join__type(graph: TENANT_API)
{
  """Lookup a location by id."""
  location(
    """The ID of the location."""
    id: ID!
  ): Location! @join__field(graph: LOCATION_API)

  """Get an annotation namespace by ID."""
  annotationNamespace(id: ID!): AnnotationNamespace! @join__field(graph: METADATA_API)
  node(id: ID!): Node @join__field(graph: NODE_RESOLVER)

  """Lookup a tenant by ID."""
  tenant(
    """The ID of the tenant."""
    id: ID!
  ): Tenant @join__field(graph: TENANT_API)
}

interface ResourceOwner
  @join__type(graph: LOCATION_API, key: "id", isInterfaceObject: true)
  @join__type(graph: METADATA_API, key: "id", isInterfaceObject: true)
  @join__type(graph: NODE_RESOLVER, key: "id")
  @join__type(graph: TENANT_API)
{
  id: ID!
  locations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Locations returned from the connection."""
    orderBy: LocationOrder

    """Filtering options for Locations returned from the connection."""
    where: LocationWhereInput
  ): LocationConnection! @join__field(graph: LOCATION_API)
  annotationNamespaces(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Ordering options for AnnotationNamespaces returned from the connection.
    """
    orderBy: AnnotationNamespaceOrder

    """
    Filtering options for AnnotationNamespaces returned from the connection.
    """
    where: AnnotationNamespaceWhereInput
  ): AnnotationNamespaceConnection! @join__field(graph: METADATA_API)
  metadata: Metadata @join__field(graph: METADATA_API)
}

type ResourceProvider implements Node & MetadataNode
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "MetadataNode")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  id: ID!
  metadata: Metadata @join__field
}

type Status implements Node
  @join__implements(graph: METADATA_API, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__type(graph: METADATA_API, key: "id")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  id: ID!
  createdAt: Time! @join__field(graph: METADATA_API)
  updatedAt: Time! @join__field(graph: METADATA_API)

  """ID of the metadata of this status"""
  metadataID: ID! @join__field(graph: METADATA_API)
  statusNamespaceID: ID! @join__field(graph: METADATA_API)
  source: String! @join__field(graph: METADATA_API)

  """JSON formatted data of this annotation."""
  data: JSON! @join__field(graph: METADATA_API)
  namespace: StatusNamespace! @join__field(graph: METADATA_API)
  metadata: Metadata! @join__field(graph: METADATA_API)
}

"""A connection to a list of items."""
type StatusConnection
  @join__type(graph: METADATA_API)
{
  """A list of edges."""
  edges: [StatusEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""Input information to delete an status."""
input StatusDeleteInput
  @join__type(graph: METADATA_API)
{
  """The node ID for this status."""
  nodeID: ID!

  """The namespace ID for this status."""
  namespaceID: ID!

  """The source for this status."""
  source: String!
}

"""Return response from statusDelete"""
type StatusDeleteResponse
  @join__type(graph: METADATA_API)
{
  """The ID of the unset status."""
  deletedID: ID!
}

"""An edge in a connection."""
type StatusEdge
  @join__type(graph: METADATA_API)
{
  """The item at the end of the edge."""
  node: Status

  """A cursor for use in pagination."""
  cursor: Cursor!
}

type StatusNamespace implements Node
  @join__implements(graph: METADATA_API, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__type(graph: METADATA_API, key: "id")
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  """The ID for the status namespace."""
  id: ID!
  createdAt: Time! @join__field(graph: METADATA_API)
  updatedAt: Time! @join__field(graph: METADATA_API)

  """The name of the status namespace."""
  name: String! @join__field(graph: METADATA_API)

  """Flag for if this namespace is private."""
  private: Boolean! @join__field(graph: METADATA_API)

  """The owner of the status namespace."""
  owner: StatusOwner! @join__field(graph: METADATA_API)
}

"""A connection to a list of items."""
type StatusNamespaceConnection
  @join__type(graph: METADATA_API)
{
  """A list of edges."""
  edges: [StatusNamespaceEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""Return response from statusNamespaceCreate"""
type StatusNamespaceCreatePayload
  @join__type(graph: METADATA_API)
{
  """The created status namespace."""
  statusNamespace: StatusNamespace!
}

"""Return response from statusNamespaceDelete"""
type StatusNamespaceDeletePayload
  @join__type(graph: METADATA_API)
{
  """The ID of the deleted status namespace."""
  deletedID: ID!

  """The count of statuss deleted"""
  statusDeletedCount: Int!
}

"""An edge in a connection."""
type StatusNamespaceEdge
  @join__type(graph: METADATA_API)
{
  """The item at the end of the edge."""
  node: StatusNamespace

  """A cursor for use in pagination."""
  cursor: Cursor!
}

"""Ordering options for StatusNamespace connections"""
input StatusNamespaceOrder
  @join__type(graph: METADATA_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order StatusNamespaces."""
  field: StatusNamespaceOrderField!
}

"""Properties by which StatusNamespace connections can be ordered."""
enum StatusNamespaceOrderField
  @join__type(graph: METADATA_API)
{
  ID @join__enumValue(graph: METADATA_API)
  CREATED_AT @join__enumValue(graph: METADATA_API)
  UPDATED_AT @join__enumValue(graph: METADATA_API)
  NAME @join__enumValue(graph: METADATA_API)
  RESOURCEPROVIDER @join__enumValue(graph: METADATA_API)
  PRIVATE @join__enumValue(graph: METADATA_API)
}

"""Return response from statusNamespaceUpdate"""
type StatusNamespaceUpdatePayload
  @join__type(graph: METADATA_API)
{
  """The updated status namespace."""
  statusNamespace: StatusNamespace!
}

"""
StatusNamespaceWhereInput is used for filtering StatusNamespace objects.
Input was generated by ent.
"""
input StatusNamespaceWhereInput
  @join__type(graph: METADATA_API)
{
  not: StatusNamespaceWhereInput
  and: [StatusNamespaceWhereInput!]
  or: [StatusNamespaceWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
}

"""Ordering options for Status connections"""
input StatusOrder
  @join__type(graph: METADATA_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order StatusSlice."""
  field: StatusOrderField!
}

"""Properties by which Status connections can be ordered."""
enum StatusOrderField
  @join__type(graph: METADATA_API)
{
  CREATED_AT @join__enumValue(graph: METADATA_API)
  UPDATED_AT @join__enumValue(graph: METADATA_API)
}

interface StatusOwner
  @join__type(graph: METADATA_API, key: "id", isInterfaceObject: true)
  @join__type(graph: NODE_RESOLVER, key: "id")
{
  id: ID!
  statusNamespaces(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for StatusNamespaces returned from the connection."""
    orderBy: StatusNamespaceOrder

    """Filtering options for StatusNamespaces returned from the connection."""
    where: StatusNamespaceWhereInput
  ): StatusNamespaceConnection! @join__field(graph: METADATA_API)
}

"""Input information to update an status."""
input StatusUpdateInput
  @join__type(graph: METADATA_API)
{
  """The node ID for this status."""
  nodeID: ID!

  """The namespace ID for this status."""
  namespaceID: ID!

  """The source for this status."""
  source: String!

  """The data to save in this status."""
  data: JSON!
}

"""Return response from statusUpdate"""
type StatusUpdateResponse
  @join__type(graph: METADATA_API)
{
  """The set status."""
  status: Status!
}

"""
StatusWhereInput is used for filtering Status objects.
Input was generated by ent.
"""
input StatusWhereInput
  @join__type(graph: METADATA_API)
{
  not: StatusWhereInput
  and: [StatusWhereInput!]
  or: [StatusWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """source field predicates"""
  source: String
  sourceNEQ: String
  sourceIn: [String!]
  sourceNotIn: [String!]
  sourceGT: String
  sourceGTE: String
  sourceLT: String
  sourceLTE: String
  sourceContains: String
  sourceHasPrefix: String
  sourceHasSuffix: String
  sourceEqualFold: String
  sourceContainsFold: String

  """namespace edge predicates"""
  hasNamespace: Boolean
  hasNamespaceWith: [StatusNamespaceWhereInput!]

  """metadata edge predicates"""
  hasMetadata: Boolean
  hasMetadataWith: [MetadataWhereInput!]
}

type Tenant implements Node & ResourceOwner
  @join__implements(graph: NODE_RESOLVER, interface: "Node")
  @join__implements(graph: NODE_RESOLVER, interface: "ResourceOwner")
  @join__implements(graph: TENANT_API, interface: "Node")
  @join__implements(graph: TENANT_API, interface: "ResourceOwner")
  @join__type(graph: NODE_RESOLVER, key: "id")
  @join__type(graph: TENANT_API, key: "id")
{
  """ID for the tenant."""
  id: ID!
  createdAt: Time! @join__field(graph: TENANT_API)
  updatedAt: Time! @join__field(graph: TENANT_API)

  """The name of a tenant."""
  name: String! @join__field(graph: TENANT_API)

  """An optional description of the tenant."""
  description: String @join__field(graph: TENANT_API)
  parent: Tenant @join__field(graph: TENANT_API)
  children(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tenants returned from the connection."""
    orderBy: TenantOrder

    """Filtering options for Tenants returned from the connection."""
    where: TenantWhereInput
  ): TenantConnection! @join__field(graph: TENANT_API)
  locations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Locations returned from the connection."""
    orderBy: LocationOrder

    """Filtering options for Locations returned from the connection."""
    where: LocationWhereInput
  ): LocationConnection! @join__field
  annotationNamespaces(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Ordering options for AnnotationNamespaces returned from the connection.
    """
    orderBy: AnnotationNamespaceOrder

    """
    Filtering options for AnnotationNamespaces returned from the connection.
    """
    where: AnnotationNamespaceWhereInput
  ): AnnotationNamespaceConnection! @join__field
  metadata: Metadata @join__field
}

"""A connection to a list of items."""
type TenantConnection
  @join__type(graph: TENANT_API)
{
  """A list of edges."""
  edges: [TenantEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""Return response from tenantCreate."""
type TenantCreatePayload
  @join__type(graph: TENANT_API)
{
  """The created tenant."""
  tenant: Tenant!
}

"""Return response from tenantDelete."""
type TenantDeletePayload
  @join__type(graph: TENANT_API)
{
  """The ID of the deleted tenant."""
  deletedID: ID!
}

"""An edge in a connection."""
type TenantEdge
  @join__type(graph: TENANT_API)
{
  """The item at the end of the edge."""
  node: Tenant

  """A cursor for use in pagination."""
  cursor: Cursor!
}

"""Ordering options for Tenant connections"""
input TenantOrder
  @join__type(graph: TENANT_API)
{
  """The ordering direction."""
  direction: OrderDirection! = ASC

  """The field by which to order Tenants."""
  field: TenantOrderField!
}

"""Properties by which Tenant connections can be ordered."""
enum TenantOrderField
  @join__type(graph: TENANT_API)
{
  CREATED_AT @join__enumValue(graph: TENANT_API)
  UPDATED_AT @join__enumValue(graph: TENANT_API)
  NAME @join__enumValue(graph: TENANT_API)
}

"""Return response from tenantUpdate."""
type TenantUpdatePayload
  @join__type(graph: TENANT_API)
{
  """The updated tenant."""
  tenant: Tenant!
}

"""
TenantWhereInput is used for filtering Tenant objects.
Input was generated by ent.
"""
input TenantWhereInput
  @join__type(graph: TENANT_API)
{
  not: TenantWhereInput
  and: [TenantWhereInput!]
  or: [TenantWhereInput!]

  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID

  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time

  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time

  """parent edge predicates"""
  hasParent: Boolean
  hasParentWith: [TenantWhereInput!]

  """children edge predicates"""
  hasChildren: Boolean
  hasChildrenWith: [TenantWhereInput!]
}

"""The builtin Time type"""
scalar Time
  @join__type(graph: LOCATION_API)
  @join__type(graph: METADATA_API)
  @join__type(graph: TENANT_API)

"""Input information to update an annotation namespace."""
input UpdateAnnotationNamespaceInput
  @join__type(graph: METADATA_API)
{
  """The name of the annotation namespace."""
  name: String

  """Flag for if this namespace is private."""
  private: Boolean
}

"""Input information to update a location."""
input UpdateLocationInput
  @join__type(graph: LOCATION_API)
{
  """The name for the location."""
  name: String

  """An optional description for the location."""
  description: String
  clearDescription: Boolean
}

"""Input information to update a status namespace."""
input UpdateStatusInput
  @join__type(graph: METADATA_API)
{
  """JSON formatted data of this annotation."""
  data: JSON
  appendData: JSON
}

"""Input information to update a status namespace."""
input UpdateStatusNamespaceInput
  @join__type(graph: METADATA_API)
{
  """The name of the status namespace."""
  name: String

  """Flag for if this namespace is private."""
  private: Boolean
}

"""Input information to update a tenant."""
input UpdateTenantInput
  @join__type(graph: TENANT_API)
{
  """The name of a tenant."""
  name: String

  """An optional description of the tenant."""
  description: String
  clearDescription: Boolean
}

schema {
  query: Query
  mutation: Mutation
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"A valid JSON string."
scalar JSON
"The builtin Time type"
scalar Time
scalar _Any
scalar _FieldSet
type Entity {
  findLoadBalancerByID(id: ID!): LoadBalancer!
  findLoadBalancerAnnotationByID(id: ID!): LoadBalancerAnnotation!
  findLoadBalancerOriginByID(id: ID!): LoadBalancerOrigin!
  findLoadBalancerPoolByID(id: ID!): LoadBalancerPool!
  findLoadBalancerPortByID(id: ID!): LoadBalancerPort!
  findLoadBalancerProviderByID(id: ID!): LoadBalancerProvider!
  findLoadBalancerStatusByID(id: ID!): LoadBalancerStatus!
  findLocationByID(id: ID!): Location!
  findOwnerByID(id: ID!): Owner!
}
type LoadBalancer implements Node & IPv4Addressable {
  "The ID for the load balancer."
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  "The name of the load balancer."
  name: String!
  annotations(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerAnnotations returned from the connection."
    orderBy: LoadBalancerAnnotationOrder,
    "Filtering options for LoadBalancerAnnotations returned from the connection."
    where: LoadBalancerAnnotationWhereInput
  ): LoadBalancerAnnotationConnection!
  statuses(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerStatusSlice returned from the connection."
    orderBy: LoadBalancerStatusOrder,
    "Filtering options for LoadBalancerStatusSlice returned from the connection."
    where: LoadBalancerStatusWhereInput
  ): LoadBalancerStatusConnection!
  ports(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerPorts returned from the connection."
    orderBy: LoadBalancerPortOrder,
    "Filtering options for LoadBalancerPorts returned from the connection."
    where: LoadBalancerPortWhereInput
  ): LoadBalancerPortConnection!
  "The load balancer provider for the load balancer."
  loadBalancerProvider: LoadBalancerProvider!
  "The location of the load balancer."
  location: Location!
  "The owner of the load balancer."
  owner: Owner!
}
type LoadBalancerAnnotation implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  loadBalancerID: ID!
  loadBalancer: LoadBalancer!
}
"A connection to a list of items."
type LoadBalancerAnnotationConnection {
  "A list of edges."
  edges: [LoadBalancerAnnotationEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"An edge in a connection."
type LoadBalancerAnnotationEdge {
  "The item at the end of the edge."
  node: LoadBalancerAnnotation
  "A cursor for use in pagination."
  cursor: Cursor!
}
"A connection to a list of items."
type LoadBalancerConnection {
  "A list of edges."
  edges: [LoadBalancerEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"Return response from loadBalancerCreate"
type LoadBalancerCreatePayload {
  "The created load balancer."
  loadBalancer: LoadBalancer!
}
"Return response from loadBalancerDelete"
type LoadBalancerDeletePayload {
  "The ID of the deleted load balancer."
  deletedID: ID!
}
"An edge in a connection."
type LoadBalancerEdge {
  "The item at the end of the edge."
  node: LoadBalancer
  "A cursor for use in pagination."
  cursor: Cursor!
}
type LoadBalancerOrigin implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  target: String!
  portNumber: Int!
  active: Boolean!
  poolID: ID!
  pool: LoadBalancerPool!
}
"A connection to a list of items."
type LoadBalancerOriginConnection {
  "A list of edges."
  edges: [LoadBalancerOriginEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"Return response from loadBalancerOriginCreate"
type LoadBalancerOriginCreatePayload {
  "The created pool origin."
  loadBalancerOrigin: LoadBalancerOrigin!
}
"Return response from loadBalancerOriginDelete"
type LoadBalancerOriginDeletePayload {
  "The deleted pool origin."
  deletedID: ID!
}
"An edge in a connection."
type LoadBalancerOriginEdge {
  "The item at the end of the edge."
  node: LoadBalancerOrigin
  "A cursor for use in pagination."
  cursor: Cursor!
}
"Return response from loadBalancerOriginUpdate"
type LoadBalancerOriginUpdatePayload {
  "The updated pool origin."
  loadBalancerOrigin: LoadBalancerOrigin!
}
type LoadBalancerPool implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  protocol: LoadBalancerPoolProtocol!
  ownerID: ID!
  ports: [LoadBalancerPort!]
  origins(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerOrigins returned from the connection."
    orderBy: LoadBalancerOriginOrder,
    "Filtering options for LoadBalancerOrigins returned from the connection."
    where: LoadBalancerOriginWhereInput
  ): LoadBalancerOriginConnection!
  "The owner of the load balancer pool."
  owner: Owner!
}
"A connection to a list of items."
type LoadBalancerPoolConnection {
  "A list of edges."
  edges: [LoadBalancerPoolEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"Return response from LoadBalancerPoolCreate"
type LoadBalancerPoolCreatePayload {
  "The created pool."
  loadBalancerPool: LoadBalancerPool!
}
"Return response from LoadBalancerPoolDelete"
type LoadBalancerPoolDeletePayload {
  "The ID of the deleted pool."
  deletedID: ID
}
"An edge in a connection."
type LoadBalancerPoolEdge {
  "The item at the end of the edge."
  node: LoadBalancerPool
  "A cursor for use in pagination."
  cursor: Cursor!
}
"Return response from LoadBalancerPoolUpdate"
type LoadBalancerPoolUpdatePayload {
  "The updated pool."
  loadBalancerPool: LoadBalancerPool!
}
type LoadBalancerPort implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  number: Int!
  name: String!
  loadBalancerID: ID!
  pools: [LoadBalancerPool!]
  loadBalancer: LoadBalancer!
}
"A connection to a list of items."
type LoadBalancerPortConnection {
  "A list of edges."
  edges: [LoadBalancerPortEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"Return response from loadBalancerPortCreate"
type LoadBalancerPortCreatePayload {
  "The created load balancer port."
  loadBalancerPort: LoadBalancerPort!
}
"Return response from loadBalancerPortDelete"
type LoadBalancerPortDeletePayload {
  "The ID of the deleted load balancer port."
  deletedID: ID!
}
"An edge in a connection."
type LoadBalancerPortEdge {
  "The item at the end of the edge."
  node: LoadBalancerPort
  "A cursor for use in pagination."
  cursor: Cursor!
}
"Return response from loadBalancerPortUpdate"
type LoadBalancerPortUpdatePayload {
  "The updated load balancer port."
  loadBalancerPort: LoadBalancerPort!
}
type LoadBalancerProvider implements Node {
  "The ID for the load balancer provider."
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  "The name of the load balancer provider."
  name: String!
  loadBalancers(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancers returned from the connection."
    orderBy: LoadBalancerOrder,
    "Filtering options for LoadBalancers returned from the connection."
    where: LoadBalancerWhereInput
  ): LoadBalancerConnection!
  "The owner of the load balancer provider."
  owner: Owner!
}
"A connection to a list of items."
type LoadBalancerProviderConnection {
  "A list of edges."
  edges: [LoadBalancerProviderEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"Return response from loadBalancerProviderCreate"
type LoadBalancerProviderCreatePayload {
  "The created load balancer provider."
  loadBalancerProvider: LoadBalancerProvider!
}
"Return response from loadBalancerProviderDelete"
type LoadBalancerProviderDeletePayload {
  "The ID of the deleted load balancer provider."
  deletedID: ID!
}
"An edge in a connection."
type LoadBalancerProviderEdge {
  "The item at the end of the edge."
  node: LoadBalancerProvider
  "A cursor for use in pagination."
  cursor: Cursor!
}
"Return response from loadBalancerProviderUpdate"
type LoadBalancerProviderUpdatePayload {
  "The updated load balancer provider."
  loadBalancerProvider: LoadBalancerProvider!
}
type LoadBalancerStatus implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  loadBalancerID: ID!
  source: String!
  loadBalancer: LoadBalancer!
}
"A connection to a list of items."
type LoadBalancerStatusConnection {
  "A list of edges."
  edges: [LoadBalancerStatusEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}
"An edge in a connection."
type LoadBalancerStatusEdge {
  "The item at the end of the edge."
  node: LoadBalancerStatus
  "A cursor for use in pagination."
  cursor: Cursor!
}
"Return response from loadBalancerUpdate"
type LoadBalancerUpdatePayload {
  "The updated load balancer."
  loadBalancer: LoadBalancer!
}
type Location {
  id: ID!
  loadBalancers(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancers returned from the connection."
    orderBy: LoadBalancerOrder,
    "Filtering options for LoadBalancers returned from the connection."
    where: LoadBalancerWhereInput
  ): LoadBalancerConnection!
}
type Mutation {
  "Create a load balancer."
  loadBalancerCreate(input: CreateLoadBalancerInput!): LoadBalancerCreatePayload!
  "Update a load balancer."
  loadBalancerUpdate(id: ID!, input: UpdateLoadBalancerInput!): LoadBalancerUpdatePayload!
  "Delete a load balancer."
  loadBalancerDelete(id: ID!): LoadBalancerDeletePayload!
  "Create a loadbalancer pool origin"
  loadBalancerOriginCreate(input: CreateLoadBalancerOriginInput!): LoadBalancerOriginCreatePayload!
  "Update a loadbalancer pool origin"
  loadBalancerOriginUpdate(id: ID!, input: UpdateLoadBalancerOriginInput!): LoadBalancerOriginUpdatePayload!
  "Delete a loadbalancer pool origin"
  loadBalancerOriginDelete(id: ID!): LoadBalancerOriginDeletePayload!
  "Create a pool."
  loadBalancerPoolCreate(input: CreateLoadBalancerPoolInput!): LoadBalancerPoolCreatePayload!
  "Update a pool."
  loadBalancerPoolUpdate(id: ID!, input: UpdateLoadBalancerPoolInput!): LoadBalancerPoolUpdatePayload!
  "Delete a pool."
  loadBalancerPoolDelete(id: ID!): LoadBalancerPoolDeletePayload!
  "Create a load balancer port."
  loadBalancerPortCreate(input: CreateLoadBalancerPortInput!): LoadBalancerPortCreatePayload!
  "Update a load balancer port."
  loadBalancerPortUpdate(id: ID!, input: UpdateLoadBalancerPortInput!): LoadBalancerPortUpdatePayload!
  "Delete a load balancer port"
  loadBalancerPortDelete(id: ID!): LoadBalancerPortDeletePayload!
  "Create a load balancer provider."
  loadBalancerProviderCreate(input: CreateLoadBalancerProviderInput!): LoadBalancerProviderCreatePayload!
  "Update a load balancer provider."
  loadBalancerProviderUpdate(id: ID!, input: UpdateLoadBalancerProviderInput!): LoadBalancerProviderUpdatePayload!
  "Delete a load balancer provider."
  loadBalancerProviderDelete(id: ID!): LoadBalancerProviderDeletePayload!
}
type Owner {
  id: ID!
  loadBalancers(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancers returned from the connection."
    orderBy: LoadBalancerOrder,
    "Filtering options for LoadBalancers returned from the connection."
    where: LoadBalancerWhereInput
  ): LoadBalancerConnection!
  loadBalancerPools(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerPools returned from the connection."
    orderBy: LoadBalancerPoolOrder,
    "Filtering options for LoadBalancerPools returned from the connection."
    where: LoadBalancerPoolWhereInput
  ): LoadBalancerPoolConnection!
  loadBalancersProviders(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerProviders returned from the connection."
    orderBy: LoadBalancerOrder,
    "Filtering options for LoadBalancerProviders returned from the connection."
    where: LoadBalancerProviderWhereInput
  ): LoadBalancerProviderConnection!
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: Cursor
  "When paginating forwards, the cursor to continue."
  endCursor: Cursor
}
type Query {
  loadBalancerPools(
    "Returns the elements in the list that come after the specified cursor."
    after: Cursor,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the elements in the list that come before the specified cursor."
    before: Cursor,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Ordering options for LoadBalancerPools returned from the connection."
    orderBy: LoadBalancerPoolOrder,
    "Filtering options for LoadBalancerPools returned from the connection."
    where: LoadBalancerPoolWhereInput
  ): LoadBalancerPoolConnection!
  "Lookup a load balancer by ID."
  loadBalancer(
    "The load balancer ID."
    id: ID!
  ): LoadBalancer!
  "Lookup a pool by ID."
  loadBalancerPool(
    "The pool ID."
    id: ID!
  ): LoadBalancerPool!
  "Lookup a load balancer provider by ID."
  loadBalancerProvider(
    "The load balancer provider ID."
    id: ID!
  ): LoadBalancerProvider!
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}
type _Service {
  sdl: String
}
interface IPv4Addressable {
  id: ID!
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node {
  "The id of the object."
  id: ID!
}
union _Entity = LoadBalancer | LoadBalancerAnnotation | LoadBalancerOrigin | LoadBalancerPool | LoadBalancerPort | LoadBalancerProvider | LoadBalancerStatus | Location | Owner
"Properties by which LoadBalancerAnnotation connections can be ordered."
enum LoadBalancerAnnotationOrderField {
  CREATED_AT
  UPDATED_AT
}
"Properties by which LoadBalancer connections can be ordered."
enum LoadBalancerOrderField {
  ID
  CREATED_AT
  UPDATED_AT
  NAME
  OWNER
}
"Properties by which LoadBalancerOrigin connections can be ordered."
enum LoadBalancerOriginOrderField {
  CREATED_AT
  UPDATED_AT
  name
  target
  number
  active
}
"Properties by which LoadBalancerPool connections can be ordered."
enum LoadBalancerPoolOrderField {
  CREATED_AT
  UPDATED_AT
  name
  protocol
}
"LoadBalancerPoolProtocol is enum for the field protocol"
enum LoadBalancerPoolProtocol {
  tcp
  udp
}
"Properties by which LoadBalancerPort connections can be ordered."
enum LoadBalancerPortOrderField {
  CREATED_AT
  UPDATED_AT
  number
  name
}
"Properties by which LoadBalancerProvider connections can be ordered."
enum LoadBalancerProviderOrderField {
  ID
  CREATED_AT
  UPDATED_AT
  NAME
  OWNER
}
"Properties by which LoadBalancerStatus connections can be ordered."
enum LoadBalancerStatusOrderField {
  CREATED_AT
  UPDATED_AT
}
"Possible directions in which to order a list of items when provided an `orderBy` argument."
enum OrderDirection {
  "Specifies an ascending order for a given `orderBy` argument."
  ASC
  "Specifies a descending order for a given `orderBy` argument."
  DESC
}
"Input information to create a load balancer."
input CreateLoadBalancerInput {
  "The name of the load balancer."
  name: String!
  "The ID for the owner for this load balancer."
  ownerID: ID!
  "The ID for the location of this load balancer."
  locationID: ID!
  portIDs: [ID!]
  providerID: ID!
}
"""
CreateLoadBalancerOriginInput is used for create LoadBalancerOrigin object.
Input was generated by ent.
"""
input CreateLoadBalancerOriginInput {
  name: String!
  target: String!
  portNumber: Int!
  active: Boolean
  poolID: ID!
}
"""
CreateLoadBalancerPoolInput is used for create LoadBalancerPool object.
Input was generated by ent.
"""
input CreateLoadBalancerPoolInput {
  name: String!
  protocol: LoadBalancerPoolProtocol!
  ownerID: ID!
  portIDs: [ID!]
  originIDs: [ID!]
}
"""
CreateLoadBalancerPortInput is used for create LoadBalancerPort object.
Input was generated by ent.
"""
input CreateLoadBalancerPortInput {
  number: Int!
  name: String!
  poolIDs: [ID!]
  loadBalancerID: ID!
}
"Input information to create a load balancer provider."
input CreateLoadBalancerProviderInput {
  "The name of the load balancer provider."
  name: String!
  "The ID for the owner for this load balancer."
  ownerID: ID!
}
"Ordering options for LoadBalancerAnnotation connections"
input LoadBalancerAnnotationOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancerAnnotations."
  field: LoadBalancerAnnotationOrderField!
}
"""
LoadBalancerAnnotationWhereInput is used for filtering LoadBalancerAnnotation objects.
Input was generated by ent.
"""
input LoadBalancerAnnotationWhereInput {
  not: LoadBalancerAnnotationWhereInput
  and: [LoadBalancerAnnotationWhereInput!]
  or: [LoadBalancerAnnotationWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "load_balancer edge predicates"
  hasLoadBalancer: Boolean
  hasLoadBalancerWith: [LoadBalancerWhereInput!]
}
"Ordering options for LoadBalancer connections"
input LoadBalancerOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancers."
  field: LoadBalancerOrderField!
}
"Ordering options for LoadBalancerOrigin connections"
input LoadBalancerOriginOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancerOrigins."
  field: LoadBalancerOriginOrderField!
}
"""
LoadBalancerOriginWhereInput is used for filtering Origin objects.
Input was generated by ent.
"""
input LoadBalancerOriginWhereInput {
  not: LoadBalancerOriginWhereInput
  and: [LoadBalancerOriginWhereInput!]
  or: [LoadBalancerOriginWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "name field predicates"
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  "target field predicates"
  target: String
  targetNEQ: String
  targetIn: [String!]
  targetNotIn: [String!]
  targetGT: String
  targetGTE: String
  targetLT: String
  targetLTE: String
  targetContains: String
  targetHasPrefix: String
  targetHasSuffix: String
  targetEqualFold: String
  targetContainsFold: String
  "port_number field predicates"
  portNumber: Int
  portNumberNEQ: Int
  portNumberIn: [Int!]
  portNumberNotIn: [Int!]
  portNumberGT: Int
  portNumberGTE: Int
  portNumberLT: Int
  portNumberLTE: Int
  "active field predicates"
  active: Boolean
  activeNEQ: Boolean
  "pool edge predicates"
  hasPool: Boolean
  hasPoolWith: [LoadBalancerPoolWhereInput!]
}
"Ordering options for LoadBalancerPool connections"
input LoadBalancerPoolOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancerPools."
  field: LoadBalancerPoolOrderField!
}
"""
LoadBalancerPoolWhereInput is used for filtering Pool objects.
Input was generated by ent.
"""
input LoadBalancerPoolWhereInput {
  not: LoadBalancerPoolWhereInput
  and: [LoadBalancerPoolWhereInput!]
  or: [LoadBalancerPoolWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "name field predicates"
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  "protocol field predicates"
  protocol: LoadBalancerPoolProtocol
  protocolNEQ: LoadBalancerPoolProtocol
  protocolIn: [LoadBalancerPoolProtocol!]
  protocolNotIn: [LoadBalancerPoolProtocol!]
  "ports edge predicates"
  hasPorts: Boolean
  hasPortsWith: [LoadBalancerPortWhereInput!]
  "origins edge predicates"
  hasOrigins: Boolean
  hasOriginsWith: [LoadBalancerOriginWhereInput!]
}
"Ordering options for LoadBalancerPort connections"
input LoadBalancerPortOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancerPorts."
  field: LoadBalancerPortOrderField!
}
"""
LoadBalancerPortWhereInput is used for filtering Port objects.
Input was generated by ent.
"""
input LoadBalancerPortWhereInput {
  not: LoadBalancerPortWhereInput
  and: [LoadBalancerPortWhereInput!]
  or: [LoadBalancerPortWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "number field predicates"
  number: Int
  numberNEQ: Int
  numberIn: [Int!]
  numberNotIn: [Int!]
  numberGT: Int
  numberGTE: Int
  numberLT: Int
  numberLTE: Int
  "name field predicates"
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  "pools edge predicates"
  hasPools: Boolean
  hasPoolsWith: [LoadBalancerPoolWhereInput!]
  "load_balancer edge predicates"
  hasLoadBalancer: Boolean
  hasLoadBalancerWith: [LoadBalancerWhereInput!]
}
"Ordering options for LoadBalancerProvider connections"
input LoadBalancerProviderOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancerProviders."
  field: LoadBalancerProviderOrderField!
}
"""
LoadBalancerProviderWhereInput is used for filtering Provider objects.
Input was generated by ent.
"""
input LoadBalancerProviderWhereInput {
  not: LoadBalancerProviderWhereInput
  and: [LoadBalancerProviderWhereInput!]
  or: [LoadBalancerProviderWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "name field predicates"
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  "load_balancers edge predicates"
  hasLoadBalancers: Boolean
  hasLoadBalancersWith: [LoadBalancerWhereInput!]
}
"Ordering options for LoadBalancerStatus connections"
input LoadBalancerStatusOrder {
  "The ordering direction."
  direction: OrderDirection! = ASC
  "The field by which to order LoadBalancerStatusSlice."
  field: LoadBalancerStatusOrderField!
}
"""
LoadBalancerStatusWhereInput is used for filtering LoadBalancerStatus objects.
Input was generated by ent.
"""
input LoadBalancerStatusWhereInput {
  not: LoadBalancerStatusWhereInput
  and: [LoadBalancerStatusWhereInput!]
  or: [LoadBalancerStatusWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "source field predicates"
  source: String
  sourceNEQ: String
  sourceIn: [String!]
  sourceNotIn: [String!]
  sourceGT: String
  sourceGTE: String
  sourceLT: String
  sourceLTE: String
  sourceContains: String
  sourceHasPrefix: String
  sourceHasSuffix: String
  sourceEqualFold: String
  sourceContainsFold: String
  "load_balancer edge predicates"
  hasLoadBalancer: Boolean
  hasLoadBalancerWith: [LoadBalancerWhereInput!]
}
"""
LoadBalancerWhereInput is used for filtering LoadBalancer objects.
Input was generated by ent.
"""
input LoadBalancerWhereInput {
  not: LoadBalancerWhereInput
  and: [LoadBalancerWhereInput!]
  or: [LoadBalancerWhereInput!]
  "id field predicates"
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  "created_at field predicates"
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  "updated_at field predicates"
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  "name field predicates"
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  "annotations edge predicates"
  hasAnnotations: Boolean
  hasAnnotationsWith: [LoadBalancerAnnotationWhereInput!]
  "statuses edge predicates"
  hasStatuses: Boolean
  hasStatusesWith: [LoadBalancerStatusWhereInput!]
  "ports edge predicates"
  hasPorts: Boolean
  hasPortsWith: [LoadBalancerPortWhereInput!]
  "provider edge predicates"
  hasProvider: Boolean
  hasProviderWith: [LoadBalancerProviderWhereInput!]
}
"Input information to update a load balancer."
input UpdateLoadBalancerInput {
  "The name of the load balancer."
  name: String
  addPortIDs: [ID!]
  removePortIDs: [ID!]
  clearPorts: Boolean
}
"""
UpdateLoadBalancerOriginInput is used for update LoadBalancerOrigin object.
Input was generated by ent.
"""
input UpdateLoadBalancerOriginInput {
  name: String
  target: String
  portNumber: Int
  active: Boolean
}
"""
UpdateLoadBalancerPoolInput is used for update LoadBalancerPool object.
Input was generated by ent.
"""
input UpdateLoadBalancerPoolInput {
  name: String
  protocol: LoadBalancerPoolProtocol
  addPortIDs: [ID!]
  removePortIDs: [ID!]
  clearPorts: Boolean
  addOriginIDs: [ID!]
  removeOriginIDs: [ID!]
  clearOrigins: Boolean
}
"""
UpdateLoadBalancerPortInput is used for update LoadBalancerPort object.
Input was generated by ent.
"""
input UpdateLoadBalancerPortInput {
  number: Int
  name: String
  addPoolIDs: [ID!]
  removePoolIDs: [ID!]
  clearPools: Boolean
}
"Input information to update a load balancer provider."
input UpdateLoadBalancerProviderInput {
  "The name of the load balancer provider."
  name: String
}
directive @extends on OBJECT | INTERFACE
directive @external on FIELD_DEFINITION | OBJECT
directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
directive @key(fields: _FieldSet!, resolvable: Boolean = true) on OBJECT | INTERFACE
directive @link(import: [String!], url: String!) on SCHEMA
directive @override(from: String!) on FIELD_DEFINITION
directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
directive @shareable on OBJECT | FIELD_DEFINITION
"The @specifiedBy built-in directive is used within the type system definition language to provide a scalar specification URL for specifying the behavior of custom scalar types."
directive @specifiedBy(url: String!) on SCALAR
directive @tag(name: String!) on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION


